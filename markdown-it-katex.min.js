// 将模块化代码转换为立即执行函数
(function(window) {
    'use strict';
    
    function isValidInlineDelim(e, t) {
        const n = e.src[t - 1],
            r = e.src[t],
            l = e.src[t + 1];
        if ("$" !== r) return {
            can_open: !1,
            can_close: !1
        };
        let s = !1,
            c = !1;
        return "$" === n || "\\" === n || void 0 !== n && !isWhitespace(n) && isWordCharacterOrNumber(n) || (s = !0), "$" === l || null != l && !isWhitespace(l) && isWordCharacterOrNumber(l) || (c = !0), {
            can_open: s,
            can_close: c
        }
    }
    
    function isWhitespace(e) {
        return /^\s$/u.test(e)
    }
    
    function isWordCharacterOrNumber(e) {
        return /^[\w\d]$/u.test(e)
    }
    
    function isValidBlockDelim(e, t) {
        const n = e.src[t - 1],
            r = e.src[t],
            l = e.src[t + 1],
            s = e.src[t + 2];
        return "$" === r && "$" !== n && "\\" !== n && "$" === l && "$" !== s ? {
            can_open: !0,
            can_close: !0
        } : {
            can_open: !1,
            can_close: !1
        }
    }
    
    function inlineMath(e, t) {
        if ("$" !== e.src[e.pos]) return !1;
        const n = e.tokens.at(-1);
        if ("html_inline" === n?.type && /^<\w+.+[^/]>$/.test(n.content)) return !1;
        let r = isValidInlineDelim(e, e.pos);
        if (!r.can_open) return t || (e.pending += "$"), e.pos += 1, !0;
        let l, s = e.pos + 1,
            c = s;
        for (; - 1 !== (c = e.src.indexOf("$", c));) {
            for (l = c - 1;
                "\\" === e.src[l];) l -= 1;
            if ((c - l) % 2 == 1) break;
            c += 1
        }
        if (-1 === c) return t || (e.pending += "$"), e.pos = s, !0;
        if (c - s == 0) return t || (e.pending += "$$"), e.pos = s + 1, !0;
        if (r = isValidInlineDelim(e, c), !r.can_close) return t || (e.pending += "$"), e.pos = s, !0;
        if (!t) {
            const t = e.push("math_inline", "math", 0);
            t.markup = "$", t.content = e.src.slice(s, c)
        }
        return e.pos = c + 1, !0
    }
    
    function blockMath(e, t, n, r) {
        let l = !1,
            s = e.bMarks[t] + e.tShift[t],
            c = e.eMarks[t];
        if (s + 2 > c) return !1;
        if ("$$" !== e.src.slice(s, s + 2)) return !1;
        s += 2;
        let i = e.src.slice(s, c);
        const o = [...i.matchAll(/\$\$/g)];
        if (1 === o.length && o[0].index === i.length - 2) i = i.trim().slice(0, -2), l = !0;
        else if (o.length > 1) return !1;
        if (r) return !0;
        let a, u, h;
        for (u = t; !l && (u++, !(u >= n)) && (s = e.bMarks[u] + e.tShift[u], c = e.eMarks[u], !(s < c && e.tShift[u] < e.blkIndent));) "$$" === e.src.slice(s, c).trim().slice(-2) ? (h = e.src.slice(0, c).lastIndexOf("$$"), a = e.src.slice(s, h), l = !0) : e.src.slice(s, c).trim().includes("$$") && (h = e.src.slice(0, c).trim().indexOf("$$"), a = e.src.slice(s, h), l = !0);
        e.line = u + 1;
        const p = e.push("math_block", "math", 0);
        return p.block = !0, p.content = (i && i.trim() ? i + "\n" : "") + e.getLines(t + 1, u, e.tShift[t], !0) + (a && a.trim() ? a : ""), p.map = [t, e.line], p.markup = "$$", !0
    }
    
    function blockBareMath(e, t, n, r) {
        const l = e.bMarks[t] + e.tShift[t],
            s = e.eMarks[t];
        if (!e.src.slice(l, s).match(/^\s*\\begin\s*\{([^{}]+)\}/)) return !1;
        if (t > 0) {
            const n = e.bMarks[t - 1] + e.tShift[t - 1],
                r = e.eMarks[t - 1],
                l = e.src.slice(n, r);
            if (!/^\s*$/.test(l)) return !1
        }
        if (r) return !0;
        const c = [];
        let i, o = t,
            a = !1;
        e: for (; !a && !(o >= n); o++) {
            const t = e.bMarks[o] + e.tShift[o],
                n = e.eMarks[o];
            if (t < n && e.tShift[o] < e.blkIndent) break;
            const r = e.src.slice(t, n);
            for (const l of r.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
                if ("\\begin" === l[1]) c.push(l[2].trim());
                else if ("\\end" === l[1] && (c.pop(), !c.length)) {
                i = e.src.slice(t, n), a = !0;
                break e
            }
        }
        e.line = o + 1;
        const u = e.push("math_block", "math", 0);
        return u.block = !0, u.content = (e.getLines(t, o, e.tShift[t], !0) + (i ?? "")).trim(), u.map = [t, e.line], u.markup = "$$", !0
    }
    
    function inlineMathBlock(e, t) {
        var n, r, l, s;
        if ("$$" !== e.src.slice(e.pos, e.pos + 2)) return !1;
        if (!isValidBlockDelim(e, e.pos).can_open) return t || (e.pending += "$$"), e.pos += 2, !0;
        for (r = n = e.pos + 2; - 1 !== (r = e.src.indexOf("$$", r));) {
            for (s = r - 1;
                "\\" === e.src[s];) s -= 1;
            if ((r - s) % 2 == 1) break;
            r += 2
        }
        return -1 === r ? (t || (e.pending += "$$"), e.pos = n, !0) : r - n == 0 ? (t || (e.pending += "$$$$"), e.pos = n + 2, !0) : isValidBlockDelim(e, r).can_close ? (t || ((l = e.push("math_block", "math", 0)).block = !0, l.markup = "$$", l.content = e.src.slice(n, r)), e.pos = r + 2, !0) : (t || (e.pending += "$$"), e.pos = n, !0)
    }
    
    function inlineBareBlock(e, t) {
        const n = e.src.slice(e.pos);
        if (!/^\n\\begin/.test(n)) return !1;
        if (e.pos += 1, t) return !0;
        const r = n.split(/\n/g).slice(1);
        let l;
        const s = [];
        e: for (var c = 0; c < r.length; ++c) {
            const e = r[c];
            for (const t of e.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
                if ("\\begin" === t[1]) s.push(t[2].trim());
                else if ("\\end" === t[1] && (s.pop(), !s.length)) {
                l = c;
                break e
            }
        }
        if (void 0 === l) return !1;
        const i = r.slice(0, l + 1).reduce(((e, t) => e + t.length), 0) + l + 1,
            o = e.push("math_inline_bare_block", "math", 0);
        return o.block = !0, o.markup = "$$", o.content = n.slice(1, i), e.pos = e.pos + i, !0
    }
    
    function handleMathInHtml(e, t, n, r) {
        const l = e.tokens;
        for (let e = l.length - 1; e >= 0; e--) {
            const s = l[e],
                c = [];
            if ("html_block" !== s.type) continue;
            const i = s.content;
            for (const e of i.matchAll(r)) {
                if (!e.groups) continue;
                const r = e.groups.html_before_math,
                    l = e.groups.math,
                    i = e.groups.html_after_math;
                r && c.push({
                    ...s,
                    type: "html_block",
                    map: null,
                    content: r
                }), l && c.push({
                    ...s,
                    type: t,
                    map: null,
                    content: l,
                    markup: n,
                    block: !0,
                    tag: "math"
                }), i && c.push({
                    ...s,
                    type: "html_block",
                    map: null,
                    content: i
                })
            }
            c.length > 0 && l.splice(e, 1, ...c)
        }
        return !0
    }
    
    function escapeHtml(e) {
        return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;")
    }
    
    function markdownItKatex(e, t) {
        const n = t?.katex ?? window.katex,
            r = t?.enableBareBlocks,
            l = t?.enableMathBlockInHtml,
            s = t?.enableMathInlineInHtml,
            c = t?.enableFencedBlocks;
        e.inline.ruler.after("escape", "math_inline", inlineMath), e.inline.ruler.after("escape", "math_inline_block", inlineMathBlock), r && e.inline.ruler.before("text", "math_inline_bare_block", inlineBareBlock), e.block.ruler.after("blockquote", "math_block", ((e, t, n, l) => !(!r || !blockBareMath(e, t, n, l)) || blockMath(e, t, n, l)), {
            alt: ["paragraph", "reference", "blockquote", "list"]
        });
        const i = /(?<html_before_math>[\s\S]*?)\$\$(?<math>[\s\S]+?)\$\$(?<html_after_math>(?:(?!\$\$[\s\S]+?\$\$)[\s\S])*)/gm,
            o = /(?<html_before_math>[\s\S]*?)\$(?<math>.*?)\$(?<html_after_math>(?:(?!\$.*?\$)[\s\S])*)/gm;
        l && e.core.ruler.push("math_block_in_html_block", (e => handleMathInHtml(e, "math_block", "$$", i))), s && e.core.ruler.push("math_inline_in_html_block", (e => handleMathInHtml(e, "math_inline", "$", o)));
        const a = e => {
                try {
                    return `<p class="katex-block">${n.renderToString(e,{...t,displayMode:!0})}</p>`
                } catch (n) {
                    return t?.throwOnError && console.log(n), `<p class="katex-block katex-error" title="${escapeHtml(e)}">${escapeHtml(n+"")}</p>`
                }
            },
            u = (e, t) => a(e[t].content) + "\n";
        if (e.renderer.rules.math_inline = (e, r) => {
                const l = e[r].content;
                return (e => {
                    const r = /\\begin\{(align|equation|gather|cd|alignat)\}/gi.test(e);
                    try {
                        return n.renderToString(e, {
                            ...t,
                            displayMode: r
                        })
                    } catch (n) {
                        return t?.throwOnError && console.log(n), `<span class="katex-error" title="${escapeHtml(e)}">${escapeHtml(n+"")}</span>`
                    }
                })(l.length > 2 && "`" === l[0] && "`" === l[l.length - 1] ? l.slice(1, -1) : l)
            }, e.renderer.rules.math_inline_block = u, e.renderer.rules.math_inline_bare_block = u, e.renderer.rules.math_block = u, c) {
            const t = "math",
                n = e.renderer.rules.fence;
            e.renderer.rules.fence = function(e, r, l, s, i) {
                const o = e[r];
                return o.info.trim().toLowerCase() === t && c ? a(o.content) + "\n" : n?.call(this, e, r, l, s, i) || ""
            }
        }
    }
    
    // 暴露到全局
    window.markdownItKatex = markdownItKatex;
    
    })(window);